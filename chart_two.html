<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Advanced Skills Galaxy — 2025</title>
  <style>
    :root {
      --glass: rgba(10,12,20,0.55);
      --accent: #7be7ff;
      --muted: #98a0b3;
      --panel: #071126;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    html, body {
      width:100%; height:100%; margin:0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    body {
      background: radial-gradient(1200px 700px at 10% 10%, #001226 0%, #00040a 28%, #000 100%);
      color: #dfefff;
      overflow: hidden;
    }
    #canvas-container {
      position: fixed;
      inset: 0;
      z-index: 1;
    }
    #title {
      position: fixed;
      left: 50%;
      top: 18px;
      transform: translateX(-50%);
      z-index: 60;
      font-weight: 700;
      padding: 8px 14px;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,0.04);
    }
    #controls {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      z-index: 60;
      display: flex;
      gap:8px;
      padding:8px;
      border-radius:10px;
      background: var(--glass);
      border:1px solid rgba(255,255,255,0.03);
    }
    .btn {
      padding:8px 12px;
      border-radius:8px;
      border:0;
      color:#041229;
      background: linear-gradient(180deg, var(--accent), #5fb8d6);
      cursor: pointer;
      font-weight:600;
    }
    .btn.secondary {
      background: transparent;
      color: var(--muted);
      border:1px solid rgba(255,255,255,0.04);
    }
    #info-panel {
      position: fixed;
      right:20px;
      top:70px;
      z-index:70;
      width:340px;
      max-height:70vh;
      overflow:auto;
      padding:16px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(8,10,18,0.7), rgba(6,8,14,0.6));
      border:1px solid rgba(255,255,255,0.04);
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      opacity:0;
      pointer-events: none;
      transition: all 300ms ease;
    }
    #info-panel.visible {
      opacity:1;
      pointer-events:auto;
    }
    #info-panel h3 {
      margin:0 0 8px;
      color: var(--accent);
      font-size:1.15rem;
    }
    #info-panel .meta {
      color: var(--muted);
      font-size:0.9rem;
      margin-bottom:12px;
    }
    .skill-row {
      padding:8px;
      border-radius:8px;
      margin-bottom:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .skill-dot {
      width:12px;
      height:12px;
      border-radius:50%;
    }
    .skill-title {
      font-size:0.95rem;
      color:#eaf6ff;
    }
    .skill-date {
      margin-left:auto;
      color:var(--muted);
      font-size:0.8rem;
    }
    .floating-label {
      position: fixed;
      z-index:80;
      padding:6px 10px;
      border-radius:8px;
      background: rgba(0,6,12,0.65);
      border:1px solid rgba(255,255,255,0.04);
      pointer-events: none;
      font-weight:600;
      font-size:0.9rem;
      display:none;
    }
    #loading {
      position: fixed;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      z-index:1000;
      background: var(--panel);
      padding:14px 18px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.03);
      box-shadow: 0 8px 40px rgba(0,0,0,0.6);
    }
    .hint {
      position: fixed;
      left:20px;
      bottom:22px;
      color: var(--muted);
      font-size:0.85rem;
      z-index:60;
    }
    @media (max-width:720px) {
      #info-panel {
        right:8px;
        left:8px;
        width: auto;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="title">Skills Galaxy — 2025</div>
  <div id="controls">
    <button class="btn" id="toggle-rotation">Pause</button>
    <button class="btn secondary" id="reset-view">Reset</button>
    <button class="btn secondary" id="focus-mode">Focus</button>
    <button class="btn secondary" id="toggle-connections">Hide Lines</button>
  </div>
  <div id="info-panel">
    <h3 id="panel-title">Category</h3>
    <div class="meta" id="panel-meta">0 skills · latest — —</div>
    <div id="skills-list"></div>
  </div>
  <div id="loading">Loading 3D models and building galaxy…</div>
  <div class="hint">Tip: hover category nodes — click to zoom in · drag to rotate</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';
    import { gsap } from 'https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js';

    // --- Data & config (unchanged) ---
    const rawData = [ /* … (your data unchanged) … */ ];
    const categoryColors = { /* … */ };
    const categoryImportance = { /* … */ };
    const categoryModels = { /* … */ };

    // --- State ---
    let scene, camera, renderer, galaxyGroup, connectionsGroup, stars;
    let raycaster, mouse = new THREE.Vector2();
    let categoryNodes = [], skillNodes = [], connections = [];
    let isRotating = true, showConnections = true, focusMode = false, focusedNode = null;
    const labels = new Map();

    async function init() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x00010a);
      scene.fog = new THREE.FogExp2(0x00010a, 0.0035);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
      camera.position.set(0,18,70);

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0x6b8190, 0x06111a, 0.7);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(30,60,50);
      dir.castShadow = true;
      dir.shadow.camera.left = -100;
      dir.shadow.camera.right = 100;
      dir.shadow.camera.top = 100;
      dir.shadow.camera.bottom = -100;
      scene.add(dir);

      galaxyGroup = new THREE.Group();
      scene.add(galaxyGroup);
      connectionsGroup = new THREE.Group();
      scene.add(connectionsGroup);

      raycaster = new THREE.Raycaster();

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = false;

      window.addEventListener('resize', onResize);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('click', onClick);

      document.getElementById('toggle-rotation').addEventListener('click', () => {
        isRotating = !isRotating;
        document.getElementById('toggle-rotation').textContent = isRotating ? 'Pause' : 'Play';
      });
      document.getElementById('reset-view').addEventListener('click', () => {
        gsap.to(camera.position, { x:0, y:18, z:70, duration:1.2, ease:'power2.out' });
        focusMode = false;
        focusedNode = null;
        restoreAll();
      });
      document.getElementById('toggle-connections').addEventListener('click', () => {
        showConnections = !showConnections;
        connectionsGroup.visible = showConnections;
        document.getElementById('toggle-connections').textContent = showConnections ? 'Hide Lines' : 'Show Lines';
      });
      document.getElementById('focus-mode').addEventListener('click', () => {
        if (focusMode) exitFocusMode();
        else if (focusedNode) enterFocusMode(focusedNode);
      });

      await loadAllModels();
      createStarfield();
      buildGalaxy();
      document.getElementById('loading').style.display = 'none';

      animate();

      function onResize() {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }

    async function loadAllModels() {
      const loader = new GLTFLoader();
      const loadedModels = {};

      // core & skill
      const corePromise  = loader.loadAsync('models/central_core.glb').then(g => normalizeModelScale(g.scene, 5)).catch(() => createFallbackCore());
      const skillPromise = loader.loadAsync('models/skill_node.glb').then(g => normalizeModelScale(g.scene, 0.8)).catch(() => createFallbackSkill());

      // category model promises
      const categoryEntries = Object.entries(categoryModels).map(async ([category, path]) => {
        try {
          const gltf = await loader.loadAsync(path);
          const importance = categoryImportance[category] || 5;
          const targetSize = 1.5 + (importance/10)*2;
          return [category, normalizeModelScale(gltf.scene, targetSize)];
        } catch(e) {
          console.warn(`Failed to load ${category} model from ${path}, using fallback`);
          return [category, createFallbackCategory(category)];
        }
      });

      const categoryResults = await Promise.all(categoryEntries);
      categoryResults.forEach(([category, model]) => loadedModels[category] = model);

      loadedModels.core  = await corePromise;
      loadedModels.skill = await skillPromise;

      // store globally
      window._loadedModels = loadedModels;  // for debug/reference
      return loadedModels;
    }

    function normalizeModelScale(model, targetSize=1) {
      const box = new THREE.Box3().setFromObject(model);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = targetSize / (maxDim || 1);
      model.scale.set(scale, scale, scale);
      model.position.set(0,0,0);
      return model;
    }

    function createFallbackCore() {
      const geometry = new THREE.IcosahedronGeometry(5, 2);
      const material = new THREE.MeshStandardMaterial({
        color: 0xffd166,
        emissive: 0xffd166,
        emissiveIntensity: 0.3,
        roughness: 0.35,
        metalness: 0.15
      });
      return new THREE.Mesh(geometry, material);
    }

    function createFallbackSkill() {
      const geometry = new THREE.OctahedronGeometry(0.45,0);
      const material = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0x444444,
        emissiveIntensity: 0.35,
        roughness: 0.3
      });
      return new THREE.Mesh(geometry, material);
    }

    function createFallbackCategory(category) {
      const importance = categoryImportance[category] || 5;
      const size = 1.8 + (importance/10)*3.2;
      const geometry = new THREE.OctahedronGeometry(size, 1);
      geometry.computeBoundingBox();
      const colour = categoryColors[category] || 0x8ab4ff;
      const material = new THREE.MeshStandardMaterial({
        color: colour,
        emissive: colour,
        emissiveIntensity: 0.18,
        roughness: 0.25,
        metalness: 0.25
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(0,0,0);
      return mesh;
    }

    function fibonacciSphere(numPoints, radius=1) {
      const points = [];
      const phi = Math.PI * (3 - Math.sqrt(5));
      for (let i=0; i<numPoints; i++) {
        const y = 1 - (i/(numPoints-1))*2;
        const r = Math.sqrt(1 - y*y);
        const theta = phi * i;
        const x = Math.cos(theta) * r;
        const z = Math.sin(theta) * r;
        points.push(new THREE.Vector3(x*radius, y*radius, z*radius));
      }
      return points;
    }

    function buildGalaxy() {
      const loadedModels = window._loadedModels;
      const core  = loadedModels.core.clone();
      core.position.set(0,0,0);
      galaxyGroup.add(core);

      const skillGroups = {};
      rawData.forEach(skill => {
        skillGroups[skill.category] ||= [];
        skillGroups[skill.category].push(skill);
      });

      const catKeys = Object.keys(skillGroups);
      const categoryPositions = fibonacciSphere(catKeys.length, 15);

      catKeys.forEach((category, i) => {
        const skills = skillGroups[category];
        const node   = loadedModels[category].clone();
        node.position.copy(categoryPositions[i]);
        node.userData = { type:'category', category, skills };
        galaxyGroup.add(node);
        categoryNodes.push(node);

        const skillPositions = fibonacciSphere(skills.length, 5);
        skills.forEach((skill, j) => {
          const skillNode = loadedModels.skill.clone();
          const pos       = skillPositions[j].clone().add(node.position);
          skillNode.position.copy(pos);
          skillNode.userData = { type:'skill', ...skill, parent: node };
          galaxyGroup.add(skillNode);
          skillNodes.push(skillNode);
          createConnection(node, skillNode);
        });
      });

      for (let i=0; i<categoryNodes.length; i++) {
        const node = categoryNodes[i];
        const next = categoryNodes[(i+1) % categoryNodes.length];
        createConnection(node, next);
      }
    }

    function createConnection(node1, node2) {
      if (!node1 || !node2) return;
      const posArray = new Float32Array([
        node1.position.x, node1.position.y, node1.position.z,
        node2.position.x, node2.position.y, node2.position.z
      ]);
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      geometry.computeBoundingSphere();
      const material = new THREE.LineBasicMaterial({
        color: 0x888888,
        transparent: true,
        opacity: 0.7
      });
      const line = new THREE.Line(geometry, material);
      connectionsGroup.add(line);
      connections.push(line);
    }

    function createStarfield() {
      const geometry = new THREE.BufferGeometry();
      const count    = 1600;
      const posArray = new Float32Array(count * 3);
      for (let i=0; i<count; i++) {
        const r     = 100 + Math.random()*600;
        const theta = Math.random()*Math.PI*2;
        const phi   = Math.acos(2*Math.random()-1);
        posArray[i*3   ] = r * Math.sin(phi) * Math.cos(theta);
        posArray[i*3+1 ] = r * Math.sin(phi) * Math.sin(theta);
        posArray[i*3+2 ] = r * Math.cos(phi);
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      geometry.computeBoundingSphere();
      const material = new THREE.PointsMaterial({
        size:1.1,
        color:0xdfefff,
        transparent:true,
        opacity:0.9
      });
      stars = new THREE.Points(geometry, material);
      scene.add(stars);
    }

    // … plus the rest of your interaction functions (onMouseMove, onClick, highlightNode, etc)
    // Same logic as before, just ensure you use modern APIs and keep them modular/clean.

    function animate() {
      requestAnimationFrame(animate);
      // … your bobbing/rotating logic …
      renderer.render(scene, camera);
    }

    // Start everything
    init().catch(err => console.error('Init failed:', err));
  </script>
</body>
</html>
